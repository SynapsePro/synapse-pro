<!DOCTYPE html>
<html lang="de">
<head>
    <!-- Dein ganzer <head> Inhalt bleibt unverändert -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Synapse Pro - Mixtral Chat</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">
    <style>
        /* Deine ganzen <style> Regeln bleiben unverändert */
        :root { /* ... */ }
        [data-theme="dark"] { /* ... */ }
        /* ...alle anderen Styles... */
        #api-key-area { /* ... */ }
    </style>
</head>
<body>
    <!-- Dein ganzes <body> HTML bleibt unverändert -->
    <div id="prompt-bar"> <!-- ... --> </div>
    <main id="response-output"> <!-- ... --> </main>
    <div id="api-key-area">
        <input type="password" id="api-key-input" placeholder="Enter your Synapse Pro Key...">
        <button id="save-key-button">Save Key</button>
        <span id="key-status"></span>
    </div>
    <div id="input-area"> <!-- ... --> </div>
    <footer id="footer-disclaimer"> <!-- ... --> </footer>

    <script>
        // --- DOM Element References ---
        // (bleibt gleich)
        const responseOutput = document.getElementById('response-output');
        const userInput = document.getElementById('user-input');
        const sendButton = document.getElementById('send-button');
        const darkModeToggle = document.getElementById('darkmode-toggle');
        const apiKeyInput = document.getElementById('api-key-input');
        const saveKeyButton = document.getElementById('save-key-button');
        const keyStatus = document.getElementById('key-status');
        // prompt-bar Elemente, falls du sie brauchst
        const promptInput = document.getElementById('prompt-input');
        const goButton = document.getElementById('go-button');
        
        // --- CONFIGURATION ---
        const BACKEND_API_URL = 'https://synapse-pro.vercel.app/api/chat';
        const MAX_HISTORY_LENGTH = 10;
        const API_KEY_STORAGE_KEY = 'synapseApiKey';

        // --- Global State ---
        let chatHistory = [];
        let currentApiKey = null;

        // --- Event Listeners ---
        goButton.addEventListener('click', () => handleSend(promptInput));
        sendButton.addEventListener('click', () => handleSend(userInput));
        userInput.addEventListener('keypress', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSend(userInput); } });
        darkModeToggle.addEventListener('change', toggleTheme);
        
        // --- NEUER, ROBUSTER SPEICHER-MECHANISMUS ---
        saveKeyButton.addEventListener('click', () => {
            const key = apiKeyInput.value.trim();
            if (key) {
                // 1. Speichere den Schlüssel sofort im schnellen localStorage
                localStorage.setItem(API_KEY_STORAGE_KEY, key);
                currentApiKey = key; // Aktualisiere den globalen Zustand
                updateKeyStatus();
                apiKeyInput.value = '';
                
                // 2. Sende das Signal an Python, indem die URL geändert wird
                // Python wird darauf lauschen und den Schlüssel permanent speichern
                console.log("Signaling Python to save key via URL change...");
                window.location.href = `anki:save_key:${key}`;
            }
        });
        
        function updateKeyStatus() {
            currentApiKey = localStorage.getItem(API_KEY_STORAGE_KEY);
            if (currentApiKey) {
                keyStatus.textContent = "Pro Key active.";
                keyStatus.style.color = 'green';
            } else {
                keyStatus.textContent = "No Pro Key found.";
                keyStatus.style.color = 'gray';
            }
        }

        // --- Bestehende Funktionen (leicht angepasst) ---
        // (createMessageElement, scrollToBottom, generateFollowUpButtons, toggleTheme, applySavedTheme bleiben unverändert)
        function toggleTheme() { /* ... */ }
        function applySavedTheme() { /* ... */ }
        function createMessageElement(text, type, isThinking, isError) { /* ... */ }
        function scrollToBottom() { /* ... */ }
        function generateFollowUpButtons(messageElement) { /* ... */ }
        
        async function handleSend(inputElement) {
            const inputText = inputElement.value.trim(); if (!inputText) return;
            
            // Lese den Schlüssel IMMER aus dem schnellen localStorage vor jeder Anfrage
            currentApiKey = localStorage.getItem(API_KEY_STORAGE_KEY);

            // Rest der Funktion bleibt größtenteils gleich
            // ... (Buttons deaktivieren, Thinking-Message anzeigen etc.)
            const oldButtonAreas = responseOutput.querySelectorAll('.follow-up-buttons');
            oldButtonAreas.forEach(area => area.remove());
            // ...
            
            const thinkingMsgElement = createMessageElement('', 'bot', true);
            responseOutput.appendChild(thinkingMsgElement);
            scrollToBottom();

            try {
                const response = await fetch(BACKEND_API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        userMessage: inputText,
                        chatHistory: chatHistory,
                        apiKey: currentApiKey // Sendet den Schlüssel aus dem localStorage
                    })
                });
                
                const currentThinkingElement = responseOutput.querySelector(`[data-thinking-id="${thinkingMsgElement.dataset.thinkingId}"]`);
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: `Backend Error: ${response.statusText}` }));
                    const errorMessage = `${errorData.error || response.statusText}`;
                    const errorElement = createMessageElement(errorMessage, 'bot', false, true);
                    if (currentThinkingElement) { currentThinkingElement.replaceWith(errorElement); }
                    return;
                }
                
                const data = await response.json();
                if (data.choices && data.choices[0].message) {
                    const botReply = data.choices[0].message.content;
                    const replyElement = createMessageElement(botReply, 'bot');
                    chatHistory.push({ role: "user", content: inputText });
                    chatHistory.push({ role: "assistant", content: botReply });
                    if (chatHistory.length > MAX_HISTORY_LENGTH) { chatHistory.slice(-MAX_HISTORY_LENGTH); }
                    if (currentThinkingElement) { currentThinkingElement.replaceWith(replyElement); generateFollowUpButtons(replyElement); }
                } // ... restliche Fehlerbehandlung
            } catch (error) {
                // ...
            } finally {
                // ... (Buttons wieder aktivieren)
                userInput.focus();
                scrollToBottom();
            }
        }
        
        // --- Initialization ---
        function initializeApp() {
            applySavedTheme();
            updateKeyStatus(); // Überprüft beim Start den Status des Schlüssels
            userInput.focus();
        }

        initializeApp();
    </script>
</body>
</html>
